-- phpMyAdmin SQL Dump
-- version 3.5.1
-- http://www.phpmyadmin.net
--
-- Хост: 127.0.0.1
-- Время создания: Июл 22 2014 г., 13:30
-- Версия сервера: 5.5.25
-- Версия PHP: 5.3.13

SET SQL_MODE="NO_AUTO_VALUE_ON_ZERO";
SET time_zone = "+00:00";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;

--
-- База данных: `blog`
--

-- --------------------------------------------------------

--
-- Структура таблицы `ci_posts`
--

CREATE TABLE IF NOT EXISTS `ci_posts` (
  `post_id` int(11) NOT NULL AUTO_INCREMENT,
  `post_author` varchar(30) NOT NULL,
  `post_subject` varchar(150) NOT NULL,
  `post_title` varchar(100) NOT NULL,
  `post_description` text NOT NULL,
  `post_content` text NOT NULL,
  `post_add_date` int(11) NOT NULL,
  `post_published` enum('0','1') NOT NULL DEFAULT '1',
  `post_url` varchar(40) NOT NULL,
  PRIMARY KEY (`post_id`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=8 ;

--
-- Дамп данных таблицы `ci_posts`
--

INSERT INTO `ci_posts` (`post_id`, `post_author`, `post_subject`, `post_title`, `post_description`, `post_content`, `post_add_date`, `post_published`, `post_url`) VALUES
(2, 'Igor', 'Передача переменных между страницами.', 'Передача переменных между страницами.', 'Передача переменных между страницами.', 'В этой статье я расскажу о том, как передавать переменные и их значения между страницами. Когда-то для меня это было не такой простой и тривиальной задачей, какой я вижу ее сейчас.\nИтак, можно выделить три основных способа передачи переменных между PHP скриптами:\nЧерез массив $_GET\nЧерез массив $_POST\nЧерез массив $_SESSION\nКаждый из этих вариантов удобен в конкретных случаях, и обычно, определить каким из массивов пользоваться не сложно. Зачем же передавать данные от одной страницы другой? Примеров масса, здесь и отправка html-формы на электронную почту, и авторизация пользователей, и работа корзины интернет магазина, а также различные фильтры и много много другого. На самом деле владеть методами работы с передачей данных между страницами необходимо любому, кто работает с PHP, без этого ну никуда. Итак, рассмотрим каждый метод передачи данных по очереди:', 1405889135, '1', 'post-1'),
(3, 'Igor', 'Пользовательские функции в PHP. Возвращаемые значения.', 'Пользовательские функции в PHP. Возвращаемые значения.', 'Пользовательские функции в PHP. Возвращаемые значения.', 'В предыдущей статье я описал каким образом можно вызвать PHP функцию, а также как передать в нее аргументы. Далее я расскажу, что может возвращать функция.\nВ принципе, функции можно условно разделить на два типа: функции возвращающие какие-либо значения, и функции, которые ничего не возвращают. Сначала рассмотрим функции, которые ничего не возвращают, а производят некоторую последовательность действий, к таким функциям можно отнести функцию hellow_user() из предыдущей статьи. Еще один пример – добавление записи в базу данных. Например, у нас есть таблица новостей, в которую надо добавить новость с описанием и названием:', 1405889346, '1', 'post-2'),
(4, 'Jack', 'Добавление поля в форму методами PHP.', 'Добавление поля в форму методами PHP.', 'Добавление поля в форму методами PHP.', 'Добавление поля в форму методом PHP.\nЕжедневно мы встречаемся с формами на интернет страницах, очень часто в них есть кнопка добавить строку. Эта кнопка передает функции JavaScript что нужно добавить еще одно поле. В интернете есть множество скриптов позволяющих это сделать, однако, для тех кто незнаком с JavaScript, или еще плохо в нем разбирается, понять как работает такой скрипты задача довольно сложная. В этой статье я постараюсь подробно описать, как создать добавление поля в форму методами PHP.\nЗадача: в форме есть поле, нужно нажатием на кнопку добавить еще одно.\nОсновная проблема в казалось бы простой задаче: у формы не может быть два действия action, если бы можно было задать их два, то проблемы бы не стояло, мы бы просто делали два обработчика, один обрабатывает форму, другой – добавляет поля.', 1405956156, '1', 'third-post'),
(5, 'Игорь', 'Пользовательские функции в PHP. Вызов функции и аргументы функции.', 'Пользовательские функции в PHP. Вызов функции и аргументы функции.', 'Пользовательские функции в PHP. Вызов функции и аргументы функции.', 'В этой статье я расскажу немного о том, как писать собственные PHP функции. Статья предназначена для людей, только начинающих изучать PHP. Сразу оговорюсь, что я не буду здесь рассматривать стандартные функции языка (про них можно прочитать в справочниках), а расскажу как применять функции и какие у них есть особенности.\r\nЧто же такое функция. Если просто – это объединенный набор операторов. Задается функция ключевым словом function. Например, простейшая функция:', 1406012272, '1', 'functions'),
(6, 'Igor', 'Объектно-ориентированное программирование в PHP (Введение).', 'Объектно-ориентированное программирование в PHP (Введение).', 'Объектно-ориентированное программирование в PHP (Введение).', 'Этой статьей я хочу начать серию статей об объектно-ориентированном программировании PHP и написании собственных классов для работы сайтов. Честно признаться, впервые познакомившись с классами и объектами я не смог понять в чем преимущества и удобства такого подхода. Однако сейчас, освоив некоторые приемы использования ООП, я строю свои сайты только на нем. \r\nСразу оговорюсь, профессиональные программисты могут меня обвинить в дилетантстве или в недостатке понимания основ ООП, но я и не претендую на гуру в области PHP, а всего лишь описываю решения проблем и освоенные мной методы. \r\nИтак, самое главное что нужно понять: \r\n1.Свойство – это переменная класса.\r\n2. Методы – функции класса.\r\nПодробнее про свойства и методы я расскажу дальше.\r\nОсновная единица ООП – класс. Что же такое класс? Класс это набор методов и свойств объекта…. А что такое объект? Трудно в двух словах объяснить, объект (или экземпляр класса) это как бы такая переменная. Может быть пока сложно, но дальше все будет проще и понятнее.\r\nИтак, начнем создание нашего первого класса. Стоит оговориться, что когда вы начнете немного ориентироваться в ООП, вы выработаете свою методику именования классов, методов и файлов, содержащих классы, но пока об этом можно не беспокоиться.', 1406013685, '1', 'php-oop'),
(7, 'Igor', 'Проверяем на сайте пользователь или нет', 'Проверяем на сайте пользователь или нет', 'Проверяем на сайте пользователь или нет', 'Когда я столкнулся с этой проблемой, решение пришлось искать довольно долго. В статье я постараюсь, по возможности подробно, описать, каким образом можно проверить находится ли авторизованный пользователь на сайте или нет.\r\nДля начала, немного о проблеме. Есть сайт. На сайте есть система авторизации. Данные пользователей хранятся в таблице users (id, username, password – самый простой вариант). Когда пользователь входит на сайт, он вводит имя пользователя и пароль, программа сопоставляет введенные пользователем в форме авторизации данные с данными в таблице пользователей и открывает для пользователя возможности, доступные только зарегистрированным пользователям. Как сделать авторизацию на PHP я уже описывал, поэтому сразу перейдем к тому, как можно проверить, на сайте ли авторизованный пользователь, или уже ушел.\r\nДля решения данной проблемы нам понадобится: немного знаний в области работы с базой данных, PHP и JQuery (для написания AJAX-запросов). Тем кто не знаком с JQuery, хочу сразу сказать – ничего страшного там нет, если вы читали статьи о том, как сделать добавление товара в корзину интернет-магазина без перезагрузки страницы, то вы уже немного познакомились с тем, как писать простые AJAX запросы.\r\nЯ буду считать, что система авторизации у вас уже налажена, поэтому подробно на ней останавливаться не буду. Далее нам понадобится еще одна таблица, назовем ее online_users. В ней создаем всего два поля user_id – идентификатор пользователя из таблицы users, и last_time – в котором будет храниться метка времени. Зачем она нужна, объясню немного позже, но уже можно догадаться. Формат поля last_time – VARCHAR(255):', 1406013773, '1', 'page-5');

-- --------------------------------------------------------

--
-- Структура таблицы `ci_posts_comments`
--

CREATE TABLE IF NOT EXISTS `ci_posts_comments` (
  `post_comment_id` int(11) NOT NULL AUTO_INCREMENT,
  `post_comment_parent_id` int(11) NOT NULL,
  `post_comment_post_id` int(11) NOT NULL,
  `post_comment_author` varchar(50) NOT NULL,
  `post_comment_content` text NOT NULL,
  `post_comment_add_date` int(11) NOT NULL,
  `post_comment_published` enum('0','1') NOT NULL DEFAULT '1',
  PRIMARY KEY (`post_comment_id`)
) ENGINE=InnoDB  DEFAULT CHARSET=utf8 AUTO_INCREMENT=8 ;

--
-- Дамп данных таблицы `ci_posts_comments`
--

INSERT INTO `ci_posts_comments` (`post_comment_id`, `post_comment_parent_id`, `post_comment_post_id`, `post_comment_author`, `post_comment_content`, `post_comment_add_date`, `post_comment_published`) VALUES
(1, 0, 2, 'Igor', 'text comment', 1405950280, '1'),
(2, 0, 2, 'Fox', 'Еще комментарий', 1405951371, '1'),
(3, 0, 2, 'Strike', 'И один комментарий', 1405951468, '1'),
(4, 0, 3, 'Автор', 'Комментарий к записи', 1405952698, '1'),
(5, 0, 5, 'Superstar', 'Комментарий к статье', 1406012320, '1'),
(6, 0, 5, 'Олеся Рябчук', 'Комментарий', 1406014590, '1'),
(7, 0, 6, 'Fox', 'Крутая статья', 1406014609, '1');

-- --------------------------------------------------------

--
-- Структура таблицы `ci_settings`
--

CREATE TABLE IF NOT EXISTS `ci_settings` (
  `setting_type` varchar(255) NOT NULL,
  `setting_parameter` varchar(255) NOT NULL,
  `setting_value` varchar(255) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

--
-- Дамп данных таблицы `ci_settings`
--

INSERT INTO `ci_settings` (`setting_type`, `setting_parameter`, `setting_value`) VALUES
('blog', 'site_name', 'Демо блог'),
('blog', 'posts_per_page', '5'),
('blog', 'excerpt_characters', '300');

/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
